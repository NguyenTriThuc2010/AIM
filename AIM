"""
Ch∆∞∆°ng tr√¨nh nh·∫≠n di·ªán v·∫≠t th·ªÉ trong game b·∫Øn s√∫ng
S·ª≠ d·ª•ng YOLOv8 v√† OpenCV ƒë·ªÉ ph√°t hi·ªán ƒë·ªëi t∆∞·ª£ng trong th·ªùi gian th·ª±c
"""

import cv2
import numpy as np
from mss import mss
import time
import pyautogui
import sys
import platform

# C·∫•u h√¨nh pyautogui ƒë·ªÉ tr√°nh l·ªói fail-safe
pyautogui.FAILSAFE = True  # Di chuy·ªÉn chu·ªôt v√†o g√≥c m√†n h√¨nh ƒë·ªÉ d·ª´ng
pyautogui.PAUSE = 0.001  # Gi·∫£m delay gi·ªØa c√°c l·ªánh

# Import Windows API n·∫øu ch·∫°y tr√™n Windows
if platform.system() == 'Windows':
    import win32gui
    import win32con
    import win32api

def setup_transparent_overlay(window_name):
    """
    Thi·∫øt l·∫≠p c·ª≠a s·ªï overlay transparent, always on top, click-through
    Ch·ªâ ho·∫°t ƒë·ªông tr√™n Windows
    """
    if platform.system() != 'Windows':
        print("‚ö† Ch·ª©c nƒÉng overlay ch·ªâ h·ªó tr·ª£ Windows")
        return None
    
    try:
        # T√¨m window handle
        hwnd = win32gui.FindWindow(None, window_name)
        if hwnd == 0:
            print(f"‚ö† Kh√¥ng t√¨m th·∫•y c·ª≠a s·ªï: {window_name}")
            return None
        
        # L·∫•y extended window style
        ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
        
        # Set window style: Always on top + Transparent + Click-through
        # WS_EX_TOPMOST: Always on top
        # WS_EX_TRANSPARENT: Click-through (chu·ªôt xuy√™n qua)
        # WS_EX_LAYERED: Cho ph√©p transparency
        ex_style = ex_style | win32con.WS_EX_TOPMOST | win32con.WS_EX_TRANSPARENT | win32con.WS_EX_LAYERED
        
        # Apply style
        win32gui.SetWindowLong(hwnd, win32con.GWL_EXSTYLE, ex_style)
        
        # Set transparency (0-255, 0 = ho√†n to√†n trong su·ªët, 255 = kh√¥ng trong su·ªët)
        # 200 = h∆°i trong su·ªët, v·∫´n nh√¨n th·∫•y r√µ
        win32gui.SetLayeredWindowAttributes(hwnd, 0, 200, win32con.LWA_ALPHA)
        
        # Set window position: Always on top
        win32gui.SetWindowPos(
            hwnd,
            win32con.HWND_TOPMOST,  # Always on top
            0, 0, 0, 0,
            win32con.SWP_NOMOVE | win32con.SWP_NOSIZE
        )
        
        # Lo·∫°i b·ªè border v√† title bar
        style = win32gui.GetWindowLong(hwnd, win32con.GWL_STYLE)
        style = style & ~win32con.WS_CAPTION & ~win32con.WS_THICKFRAME
        win32gui.SetWindowLong(hwnd, win32con.GWL_STYLE, style)
        
        print("‚úì ƒê√£ k√≠ch ho·∫°t overlay mode:")
        print("  - Always on top")
        print("  - Click-through (chu·ªôt xuy√™n qua)")
        print("  - Transparent (ƒë·ªô trong su·ªët 200/255)")
        
        return hwnd
    except Exception as e:
        print(f"‚ö† L·ªói khi thi·∫øt l·∫≠p overlay: {e}")
        return None

def set_fullscreen_borderless(window_name):
    """
    ƒê·∫∑t c·ª≠a s·ªï th√†nh fullscreen borderless
    """
    if platform.system() != 'Windows':
        return None
    
    try:
        hwnd = win32gui.FindWindow(None, window_name)
        if hwnd == 0:
            return None
        
        # L·∫•y k√≠ch th∆∞·ªõc m√†n h√¨nh
        screen_width = win32api.GetSystemMetrics(0)
        screen_height = win32api.GetSystemMetrics(1)
        
        # Set fullscreen borderless
        win32gui.SetWindowPos(
            hwnd,
            win32con.HWND_TOPMOST,
            0, 0,
            screen_width, screen_height,
            win32con.SWP_SHOWWINDOW
        )
        
        print(f"‚úì Fullscreen borderless: {screen_width}x{screen_height}")
        return hwnd
    except Exception as e:
        print(f"‚ö† L·ªói khi set fullscreen: {e}")
        return None

class GameObjectDetector:
    def __init__(self, confidence_threshold=0.5, auto_aim=False, sensitivity=1.0, overlay_mode=True):
        """
        Kh·ªüi t·∫°o b·ªô nh·∫≠n di·ªán v·∫≠t th·ªÉ
        
        Args:
            confidence_threshold: Ng∆∞·ª°ng tin c·∫≠y t·ªëi thi·ªÉu ƒë·ªÉ ph√°t hi·ªán
            auto_aim: B·∫≠t/t·∫Øt t·ª± ƒë·ªông quay camera v·ªÅ m·ª•c ti√™u
            sensitivity: ƒê·ªô nh·∫°y di chuy·ªÉn chu·ªôt (0.1 - 2.0)
            overlay_mode: B·∫≠t ch·∫ø ƒë·ªô overlay (always on top, click-through, transparent)
        """
        self.confidence_threshold = confidence_threshold
        self.auto_aim = auto_aim
        self.sensitivity = sensitivity
        self.overlay_mode = overlay_mode
        
        # C·∫•u h√¨nh v√πng capture m√†n h√¨nh (c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh)
        self.monitor = {"top": 0, "left": 0, "width": 1920, "height": 1080}
        self.sct = mss()
        
        # Load YOLO model (c·∫ßn c√†i ƒë·∫∑t ultralytics)
        # pip install ultralytics
        try:
            from ultralytics import YOLO
            # S·ª≠ d·ª•ng model YOLOv8 (t·∫£i t·ª± ƒë·ªông n·∫øu ch∆∞a c√≥)
            self.model = YOLO('yolov8n.pt')  # 'n' = nano (nhanh nh·∫•t)
            print("‚úì ƒê√£ load model YOLO th√†nh c√¥ng")
        except ImportError:
            print("‚ö† C·∫ßn c√†i ƒë·∫∑t: pip install ultralytics")
            self.model = None
        
        # C√°c l·ªõp ƒë·ªëi t∆∞·ª£ng c·∫ßn ph√°t hi·ªán (t√πy ch·ªânh theo game)
        self.target_classes = ['person', 'car', 'truck', 'motorcycle', 'airplane']
        
        # M√†u s·∫Øc cho c√°c bounding box
        self.colors = {
            'person': (0, 255, 0),      # Xanh l√°
            'car': (255, 0, 0),          # ƒê·ªè
            'truck': (0, 0, 255),        # Xanh d∆∞∆°ng
            'motorcycle': (255, 255, 0), # V√†ng
            'airplane': (255, 0, 255)    # T√≠m
        }
        
    def capture_screen(self):
        """Ch·ª•p m√†n h√¨nh game"""
        screenshot = self.sct.grab(self.monitor)
        img = np.array(screenshot)
        img = cv2.cvtColor(img, cv2.COLOR_BGRA2BGR)
        return img
    
    def detect_objects(self, frame):
        """
        Ph√°t hi·ªán v·∫≠t th·ªÉ trong frame
        
        Returns:
            frame: Frame ƒë√£ ƒë∆∞·ª£c v·∫Ω bounding box
            detections: Danh s√°ch c√°c ƒë·ªëi t∆∞·ª£ng ph√°t hi·ªán ƒë∆∞·ª£c
        """
        if self.model is None:
            return frame, []
        
        # Ch·∫°y detection
        results = self.model(frame, conf=self.confidence_threshold, verbose=False)
        
        detections = []
        
        # X·ª≠ l√Ω k·∫øt qu·∫£
        for result in results:
            boxes = result.boxes
            
            for box in boxes:
                # L·∫•y th√¥ng tin box
                x1, y1, x2, y2 = box.xyxy[0].cpu().numpy()
                conf = box.conf[0].cpu().numpy()
                cls = int(box.cls[0].cpu().numpy())
                
                # L·∫•y t√™n class
                class_name = self.model.names[cls]
                
                # Ch·ªâ x·ª≠ l√Ω c√°c ƒë·ªëi t∆∞·ª£ng m·ª•c ti√™u
                if class_name in self.target_classes:
                    # T√≠nh to√°n t√¢m c·ªßa box
                    center_x = int((x1 + x2) / 2)
                    center_y = int((y1 + y2) / 2)
                    
                    detection_info = {
                        'class': class_name,
                        'confidence': float(conf),
                        'bbox': (int(x1), int(y1), int(x2), int(y2)),
                        'center': (center_x, center_y)
                    }
                    detections.append(detection_info)
        
        # KH√îNG v·∫Ω g√¨ l√™n frame ·ªü ƒë√¢y n·ªØa
        # T·∫•t c·∫£ s·∫Ω ƒë∆∞·ª£c v·∫Ω trong h√†m run()
        return frame, detections
    
    def find_nearest_target(self, detections, screen_center):
        """
        T√¨m m·ª•c ti√™u g·∫ßn t√¢m m√†n h√¨nh nh·∫•t
        
        Args:
            detections: Danh s√°ch c√°c ƒë·ªëi t∆∞·ª£ng
            screen_center: T·ªça ƒë·ªô t√¢m m√†n h√¨nh
        
        Returns:
            Th√¥ng tin m·ª•c ti√™u g·∫ßn nh·∫•t ho·∫∑c None
        """
        if not detections:
            return None
        
        min_distance = float('inf')
        nearest = None
        
        for detection in detections:
            # T√≠nh kho·∫£ng c√°ch t·ª´ t√¢m ƒë·ªëi t∆∞·ª£ng ƒë·∫øn t√¢m m√†n h√¨nh
            dx = detection['center'][0] - screen_center[0]
            dy = detection['center'][1] - screen_center[1]
            distance = np.sqrt(dx**2 + dy**2)
            
            if distance < min_distance:
                min_distance = distance
                nearest = detection
                nearest['distance'] = distance
        
        return nearest
    
    def auto_aim_to_target(self, target, screen_center, smooth=True):
        """
        T·ª± ƒë·ªông di chuy·ªÉn chu·ªôt ƒë·∫øn m·ª•c ti√™u
        
        Args:
            target: Th√¥ng tin m·ª•c ti√™u (c√≥ 'center')
            screen_center: T√¢m m√†n h√¨nh
            smooth: S·ª≠ d·ª•ng di chuy·ªÉn m∆∞·ª£t m√†
        """
        if not target or not self.auto_aim:
            return
        
        # T√≠nh offset c·∫ßn di chuy·ªÉn
        offset_x = target['center'][0] - screen_center[0]
        offset_y = target['center'][1] - screen_center[1]
        
        # √Åp d·ª•ng ƒë·ªô nh·∫°y
        move_x = offset_x * self.sensitivity
        move_y = offset_y * self.sensitivity
        
        # V√πng ch·∫øt (dead zone) - kh√¥ng di chuy·ªÉn n·∫øu qu√° g·∫ßn t√¢m
        dead_zone = 10
        if abs(offset_x) < dead_zone and abs(offset_y) < dead_zone:
            return
        
        # Di chuy·ªÉn chu·ªôt
        try:
            if smooth:
                # Di chuy·ªÉn m∆∞·ª£t v·ªõi th·ªùi gian ng·∫Øn
                duration = 0.05  # 50ms
                pyautogui.moveRel(move_x, move_y, duration=duration)
            else:
                # Di chuy·ªÉn ngay l·∫≠p t·ª©c
                pyautogui.moveRel(move_x, move_y, duration=0)
        except Exception as e:
            print(f"‚ö† L·ªói di chuy·ªÉn chu·ªôt: {e}")
    
    def run(self, show_fps=True):
        """
        Ch·∫°y v√≤ng l·∫∑p nh·∫≠n di·ªán ch√≠nh
        
        Args:
            show_fps: Hi·ªÉn th·ªã FPS tr√™n m√†n h√¨nh
        """
        print("üéÆ B·∫Øt ƒë·∫ßu nh·∫≠n di·ªán v·∫≠t th·ªÉ trong game...")
        print("=" * 60)
        print("PH√çM ƒêI·ªÄU KHI·ªÇN:")
        print("  Q: Tho√°t ch∆∞∆°ng tr√¨nh")
        print("  S: Ch·ª•p ·∫£nh m√†n h√¨nh")
        print("  A: B·∫≠t/t·∫Øt Auto-Aim")
        print("  +: TƒÉng ƒë·ªô nh·∫°y")
        print("  -: Gi·∫£m ƒë·ªô nh·∫°y")
        print("  O: B·∫≠t/t·∫Øt Overlay Mode")
        print("  T: ƒêi·ªÅu ch·ªânh ƒë·ªô trong su·ªët")
        print("=" * 60)
        print(f"‚öôÔ∏è  Auto-Aim: {'B·∫¨T' if self.auto_aim else 'T·∫ÆT'}")
        print(f"‚öôÔ∏è  Sensitivity: {self.sensitivity:.2f}")
        print(f"‚öôÔ∏è  Overlay Mode: {'B·∫¨T' if self.overlay_mode else 'T·∫ÆT'}")
        print("=" * 60)
        
        # T√™n c·ª≠a s·ªï
        window_name = 'Game Object Detection - Overlay'
        
        # T·∫°o c·ª≠a s·ªï v·ªõi flag fullscreen
        cv2.namedWindow(window_name, cv2.WINDOW_NORMAL)
        cv2.setWindowProperty(window_name, cv2.WND_PROP_FULLSCREEN, cv2.WINDOW_FULLSCREEN)
        
        # L·∫•y k√≠ch th∆∞·ªõc m√†n h√¨nh th·ª±c t·∫ø
        if platform.system() == 'Windows':
            screen_width = win32api.GetSystemMetrics(0)
            screen_height = win32api.GetSystemMetrics(1)
        else:
            screen_width = self.monitor['width']
            screen_height = self.monitor['height']
        
        screen_center = (screen_width // 2, screen_height // 2)
        
        # Wait m·ªôt ch√∫t ƒë·ªÉ window ƒë∆∞·ª£c t·∫°o
        cv2.waitKey(100)
        
        # Setup overlay mode n·∫øu ƒë∆∞·ª£c b·∫≠t
        hwnd = None
        if self.overlay_mode and platform.system() == 'Windows':
            hwnd = setup_transparent_overlay(window_name)
            if hwnd:
                set_fullscreen_borderless(window_name)
        
        frame_count = 0
        start_time = time.time()
        transparency_level = 200  # 0-255
        
        while True:
            # Ch·ª•p m√†n h√¨nh
            frame = self.capture_screen()
            
            # Ph√°t hi·ªán v·∫≠t th·ªÉ
            processed_frame, detections = self.detect_objects(frame)
            
            # T√¨m m·ª•c ti√™u g·∫ßn nh·∫•t
            nearest_target = self.find_nearest_target(detections, screen_center)
            
            # N·∫øu ·ªü overlay mode, t·∫°o n·ªÅn ƒëen ho√†n to√†n
            if self.overlay_mode:
                # T·∫°o m·ªôt frame ƒëen ho√†n to√†n (n·ªÅn trong su·ªët)
                overlay = np.zeros((frame.shape[0], frame.shape[1], 3), dtype=np.uint8)
            else:
                # Normal mode - hi·ªÉn th·ªã m√†n h√¨nh game
                overlay = processed_frame.copy()
            
            # V·∫Ω t·∫•t c·∫£ c√°c detection l√™n overlay
            for detection in detections:
                class_name = detection['class']
                conf = detection['confidence']
                x1, y1, x2, y2 = detection['bbox']
                center_x, center_y = detection['center']
                
                # V·∫Ω bounding box
                color = self.colors.get(class_name, (0, 255, 0))
                cv2.rectangle(overlay, (x1, y1), (x2, y2), color, 2)
                
                # V·∫Ω nh√£n
                label = f"{class_name}: {conf:.2f}"
                cv2.putText(overlay, label, (x1, y1 - 10),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.5, color, 2)
                
                # V·∫Ω t√¢m c·ªßa detection
                cv2.circle(overlay, (center_x, center_y), 5, (0, 0, 255), -1)
                cv2.drawMarker(overlay, (center_x, center_y), (255, 255, 255),
                             cv2.MARKER_CROSS, 20, 2)
            
            # Auto-aim n·∫øu ƒë∆∞·ª£c b·∫≠t
            if self.auto_aim and nearest_target:
                self.auto_aim_to_target(nearest_target, screen_center, smooth=True)
                
                # V·∫Ω ƒë∆∞·ªùng k·∫ª t·ª´ t√¢m ƒë·∫øn m·ª•c ti√™u
                cv2.line(overlay, screen_center, nearest_target['center'],
                        (0, 255, 255), 2)
                
                # V·∫Ω v√≤ng tr√≤n nh·∫•n m·∫°nh m·ª•c ti√™u
                cv2.circle(overlay, nearest_target['center'], 
                          30, (0, 255, 255), 2)
            
            # Hi·ªÉn th·ªã th√¥ng tin m·ª•c ti√™u
            if nearest_target:
                info_text = f"Target: {nearest_target['class']} | " \
                           f"Distance: {nearest_target['distance']:.0f}px | " \
                           f"Conf: {nearest_target['confidence']:.2f}"
                cv2.putText(overlay, info_text, (10, 30),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 255), 2)
            
            # Hi·ªÉn th·ªã FPS
            if show_fps:
                frame_count += 1
                elapsed_time = time.time() - start_time
                fps = frame_count / elapsed_time
                cv2.putText(overlay, f"FPS: {fps:.1f}", (10, 60),
                          cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            
            # Hi·ªÉn th·ªã s·ªë l∆∞·ª£ng ph√°t hi·ªán
            cv2.putText(overlay, f"Detected: {len(detections)}", (10, 90),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 0), 2)
            
            # Hi·ªÉn th·ªã tr·∫°ng th√°i Auto-Aim
            auto_aim_status = "AUTO-AIM: ON" if self.auto_aim else "AUTO-AIM: OFF"
            auto_aim_color = (0, 255, 0) if self.auto_aim else (0, 0, 255)
            cv2.putText(overlay, auto_aim_status, (10, 120),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.7, auto_aim_color, 2)
            
            # Hi·ªÉn th·ªã ƒë·ªô nh·∫°y
            cv2.putText(overlay, f"Sensitivity: {self.sensitivity:.2f}", (10, 150),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 255, 255), 2)
            
            # Hi·ªÉn th·ªã Overlay mode
            overlay_status = "OVERLAY: ON" if self.overlay_mode else "OVERLAY: OFF"
            overlay_color = (0, 255, 255) if self.overlay_mode else (128, 128, 128)
            cv2.putText(overlay, overlay_status, (10, 180),
                      cv2.FONT_HERSHEY_SIMPLEX, 0.7, overlay_color, 2)
            
            # V·∫Ω crosshair t√¢m m√†n h√¨nh (to h∆°n v√† n·ªïi b·∫≠t h∆°n)
            crosshair_size = 40
            crosshair_thickness = 3
            crosshair_color = (0, 255, 255)  # V√†ng cyan
            
            # V·∫Ω ch·ªØ th·∫≠p
            cv2.line(overlay, 
                    (screen_center[0] - crosshair_size, screen_center[1]),
                    (screen_center[0] + crosshair_size, screen_center[1]),
                    crosshair_color, crosshair_thickness)
            cv2.line(overlay, 
                    (screen_center[0], screen_center[1] - crosshair_size),
                    (screen_center[0], screen_center[1] + crosshair_size),
                    crosshair_color, crosshair_thickness)
            
            # V·∫Ω v√≤ng tr√≤n ·ªü t√¢m
            cv2.circle(overlay, screen_center, 5, crosshair_color, -1)
            cv2.circle(overlay, screen_center, 25, crosshair_color, 2)
            
            # Hi·ªÉn th·ªã frame
            display_frame = overlay
            
            # Resize v·ªÅ ƒë√∫ng k√≠ch th∆∞·ªõc m√†n h√¨nh n·∫øu c·∫ßn
            if display_frame.shape[0] != screen_height or display_frame.shape[1] != screen_width:
                display_frame = cv2.resize(display_frame, (screen_width, screen_height))
            
            cv2.imshow(window_name, display_frame)
            
            # X·ª≠ l√Ω ph√≠m
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                break
            elif key == ord('s'):
                filename = f"screenshot_{int(time.time())}.png"
                cv2.imwrite(filename, overlay)
                print(f"üì∏ ƒê√£ l∆∞u: {filename}")
            elif key == ord('a'):
                self.auto_aim = not self.auto_aim
                status = "B·∫¨T" if self.auto_aim else "T·∫ÆT"
                print(f"üéØ Auto-Aim: {status}")
            elif key == ord('+') or key == ord('='):
                self.sensitivity = min(2.0, self.sensitivity + 0.1)
                print(f"‚öôÔ∏è  Sensitivity: {self.sensitivity:.2f}")
            elif key == ord('-') or key == ord('_'):
                self.sensitivity = max(0.1, self.sensitivity - 0.1)
                print(f"‚öôÔ∏è  Sensitivity: {self.sensitivity:.2f}")
            elif key == ord('o'):
                self.overlay_mode = not self.overlay_mode
                if self.overlay_mode and platform.system() == 'Windows':
                    hwnd = setup_transparent_overlay(window_name)
                    if hwnd:
                        set_fullscreen_borderless(window_name)
                else:
                    # T·∫Øt overlay mode - kh√¥i ph·ª•c c·ª≠a s·ªï b√¨nh th∆∞·ªùng
                    if platform.system() == 'Windows' and hwnd:
                        try:
                            ex_style = win32gui.GetWindowLong(hwnd, win32con.GWL_EXSTYLE)
                            ex_style = ex_style & ~win32con.WS_EX_TRANSPARENT & ~win32con.WS_EX_LAYERED
                            win32gui.SetWindowLong(hwnd, win32con.GWL_EXSTYLE, ex_style)
                        except:
                            pass
                status = "B·∫¨T" if self.overlay_mode else "T·∫ÆT"
                print(f"üëÅÔ∏è  Overlay Mode: {status}")
            elif key == ord('t'):
                if platform.system() == 'Windows' and hwnd and self.overlay_mode:
                    transparency_level = (transparency_level + 50) % 300
                    if transparency_level == 0:
                        transparency_level = 50
                    actual_level = min(255, transparency_level)
                    win32gui.SetLayeredWindowAttributes(hwnd, 0, actual_level, win32con.LWA_ALPHA)
                    print(f"üîç ƒê·ªô trong su·ªët: {actual_level}/255")
        
        # D·ªçn d·∫πp
        cv2.destroyAllWindows()
        print("\n‚úì K·∫øt th√∫c ch∆∞∆°ng tr√¨nh")


def main():
    """H√†m main"""
    print("=" * 60)
    print("üéØ CH∆Ø∆†NG TR√åNH NH·∫¨N DI·ªÜN V·∫¨T TH·ªÇ TRONG GAME B·∫ÆN S√öNG")
    print("=" * 60)
    
    # Kh·ªüi t·∫°o detector v·ªõi overlay mode B·∫¨T
    detector = GameObjectDetector(
        confidence_threshold=0.4,
        auto_aim=Trueq,     # B·∫≠t/t·∫Øt auto-aim (nh·∫•n 'A' trong game ƒë·ªÉ toggle)
        sensitivity=2,    # ƒê·ªô nh·∫°y (0.1 - 2.0, d√πng +/- ƒë·ªÉ ƒëi·ªÅu ch·ªânh)q
        overlay_mode=True   # B·∫¨T ch·∫ø ƒë·ªô overlay (always on top, click-through)
    )
    
    # Ch·∫°y detection
    detector.run(show_fps=True)


if __name__ == "__main__":
    main()
